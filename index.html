<!DOCTYPE html>
<html lang="ar" dir="rtl" id="htmlTag">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flapworld</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&family=Fredoka:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { 
            --glass: rgba(10, 15, 30, 0.85); 
            --border: rgba(255, 255, 255, 0.1); 
            --accent: #facc15;
        }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #010409; 
            font-family: 'Cairo', sans-serif; 
            touch-action: none; 
            user-select: none; 
            color: white; 
        }
        body.en { font-family: 'Fredoka', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; background: #000; }
        
        .ui-screen { 
            position: absolute; 
            inset: 0; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            z-index: 100; 
            transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1); 
            backdrop-filter: blur(12px); 
        }
        .hidden-screen { opacity: 0; pointer-events: none; transform: scale(0.9); }
        .glass-card { 
            background: var(--glass); 
            border: 1px solid var(--border); 
            border-radius: 2.5rem; 
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); 
        }
        
        .btn-action { transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1); cursor: pointer; position: relative; overflow: hidden; }
        .btn-action:active { transform: scale(0.95); }
        
        #toast { 
            position: absolute; 
            top: 30px; 
            left: 50%; 
            transform: translateX(-50%) translateY(-150%); 
            transition: 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55); 
        }
        #toast.show { transform: translateX(-50%) translateY(0); }
        
        .custom-scroll::-webkit-scrollbar { width: 5px; }
        .custom-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }

        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }
        .float-logo { animation: float 4s ease-in-out infinite; }

        .score-pop { animation: pop 0.3s ease-out; }
        @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.3); color: var(--accent); } 100% { transform: scale(1); } }
        
        .tutorial-item { animation: slideUp 0.6s ease-out forwards; opacity: 0; }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        
        /* Loading screen */
        #loadingScreen {
            position: fixed;
            inset: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            color: white;
            font-family: 'Cairo', sans-serif;
        }
        #loadingScreen.hidden { display: none; }
        .loader {
            border: 3px solid #333;
            border-top: 3px solid #facc15;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <div class="loader"></div>
        <div>ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ...</div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Tutorial Overlay -->
    <div id="tutorialOverlay" class="hidden-screen ui-screen z-[150] bg-black/60">
        <div class="glass-card p-10 w-80 text-center">
            <h2 class="text-3xl font-black text-yellow-400 mb-8" data-t="howToPlay">ŸÉŸäŸÅŸäÿ© ÿßŸÑŸÑÿπÿ®</h2>
            <div class="space-y-6 text-right" dir="rtl">
                <div class="tutorial-item flex items-center gap-4" style="animation-delay: 0.1s">
                    <span class="text-3xl">üëÜ</span>
                    <span class="text-white font-bold" data-t="t1">ÿßŸÜŸÇÿ± ÿπŸÑŸâ ÿßŸÑÿ¥ÿßÿ¥ÿ© ŸÑŸÑÿ™ÿ≠ŸÑŸäŸÇ</span>
                </div>
                <div class="tutorial-item flex items-center gap-4" style="animation-delay: 0.2s">
                    <span class="text-3xl">üö´</span>
                    <span class="text-white font-bold" data-t="t2">ŸÑÿß ÿ™ÿµÿ∑ÿØŸÖ ÿ®ÿßŸÑÿ£ÿπŸÖÿØÿ©</span>
                </div>
                <div class="tutorial-item flex items-center gap-4" style="animation-delay: 0.3s">
                    <span class="text-3xl">‚ö†Ô∏è</span>
                    <span class="text-white font-bold" data-t="t3">ŸÑÿß ÿ™ÿ≥ŸÇÿ∑ ÿÆÿßÿ±ÿ¨ ÿßŸÑÿ¥ÿßÿ¥ÿ©</span>
                </div>
            </div>
            <button onclick="UI.closeTutorial()" class="mt-10 w-full bg-yellow-400 text-black font-black py-4 rounded-2xl shadow-lg" data-t="gotIt">ŸÅŸáŸÖÿ™!</button>
        </div>
    </div>

    <!-- HUD -->
    <div id="hud" class="hidden absolute top-0 left-0 w-full p-6 flex justify-between items-start pointer-events-none z-10">
        <div class="flex flex-col gap-2">
            <div class="text-7xl font-black text-white drop-shadow-2xl transition-transform" id="scoreDisplay">0</div>
            <div id="locationHud" class="bg-black/40 backdrop-blur-xl px-5 py-2 rounded-full border border-white/10 flex items-center gap-3">
                <span id="hudFlag" class="text-2xl">‚òÄÔ∏è</span> 
                <span id="hudLocName" class="text-xs font-bold tracking-widest uppercase">Spring Valley</span>
            </div>
        </div>
        <div class="glass-card px-6 py-3 text-center border-yellow-500/30">
            <div class="text-[10px] text-yellow-400 font-black uppercase tracking-widest" data-t="bestScore">ÿßŸÑÿ£ŸÅÿ∂ŸÑ</div>
            <div class="text-2xl font-black text-white" id="bestScoreDisplay">0</div>
        </div>
    </div>

    <!-- Notifications -->
    <div id="toast" class="z-[200] glass-card px-8 py-4 flex items-center gap-5 border-l-4 border-yellow-400">
        <span id="toastIcon" class="text-3xl">üåç</span>
        <div class="flex flex-col">
            <span id="toastMsg" class="text-white font-black text-lg">Ÿàÿ¨Ÿáÿ© ÿ¨ÿØŸäÿØÿ©!</span>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="mainMenu" class="ui-screen">
        <div class="mb-12 text-center float-logo flex flex-col items-center">
            <h1 class="text-7xl font-black tracking-tighter text-white uppercase italic">Flap<span class="text-yellow-400">world</span></h1>
            <div class="mt-4 px-4 py-1 bg-white/10 rounded-full text-[10px] font-bold tracking-widest uppercase opacity-40">Global Tour Edition</div>
        </div>
        
        <div class="w-80 flex flex-col gap-4">
            <button onclick="Game.handleMainAction()" class="btn-action bg-yellow-400 hover:bg-yellow-300 text-black font-black py-6 rounded-3xl text-2xl shadow-2xl shadow-yellow-400/30" data-t="playNow">ÿßŸÜÿ∑ŸÑÿßŸÇ</button>
            <div class="grid grid-cols-2 gap-4">
                <button onclick="UI.showSkins()" class="btn-action glass-card hover:bg-white/10 text-white font-bold py-5 rounded-3xl text-xs uppercase tracking-widest" data-t="hangar">ÿßŸÑÿ£ÿ®ÿ∑ÿßŸÑ</button>
                <button onclick="UI.showSettings()" class="btn-action glass-card hover:bg-white/10 text-white font-bold py-5 rounded-3xl text-xs uppercase tracking-widest" data-t="settings">ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</button>
            </div>
        </div>
    </div>

    <!-- Skins Shop -->
    <div id="skinsScreen" class="ui-screen hidden-screen">
        <div class="glass-card p-8 w-[95%] max-w-md max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-end mb-8 border-b border-white/10 pb-6">
                <h2 class="text-3xl font-black text-white" data-t="chooseBird">ÿßŸÑÿ£ÿ®ÿ∑ÿßŸÑ</h2>
                <div class="flex flex-col items-end">
                    <span class="text-[10px] text-white/40 font-bold uppercase" data-t="best">ÿ£ŸÅÿ∂ŸÑ ŸÜÿ™Ÿäÿ¨ÿ©</span>
                    <span class="text-yellow-400 text-xl font-black" id="skinPts">0</span>
                </div>
            </div>
            <div id="skinsGrid" class="custom-scroll overflow-y-auto flex-1 space-y-4 pr-3"></div>
            <button onclick="UI.showMenu()" class="mt-8 bg-white/5 hover:bg-white/10 text-white font-black py-5 rounded-3xl transition-all" data-t="back">ÿ•ÿ∫ŸÑÿßŸÇ</button>
        </div>
    </div>

    <!-- Settings -->
    <div id="settingsScreen" class="ui-screen hidden-screen">
        <div class="glass-card p-10 w-80">
            <h2 class="text-3xl font-black text-white mb-12 text-center tracking-tighter" data-t="settings">ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™</h2>
            <div class="space-y-10">
                <div class="flex justify-between items-center">
                    <span class="text-white/60 font-bold text-sm uppercase tracking-widest" data-t="language">ÿßŸÑŸÑÿ∫ÿ©</span>
                    <button onclick="Lang.toggle()" class="bg-white/10 hover:bg-white/20 text-white px-6 py-2 rounded-full font-black text-xs" id="langBtn">AR</button>
                </div>
                <div class="flex justify-between items-center">
                    <span class="text-white/60 font-bold text-sm uppercase tracking-widest" data-t="sfx">ÿßŸÑÿµŸàÿ™</span>
                    <button id="sfxToggle" onclick="AudioSys.toggleSFX()" class="w-16 h-8 bg-white/10 rounded-full relative transition-all">
                        <div class="absolute left-1 top-1 w-6 h-6 bg-white rounded-full transition-all shadow-md" id="sfxKnob"></div>
                    </button>
                </div>
            </div>
            <button onclick="UI.showMenu()" class="mt-12 w-full bg-yellow-400 text-black font-black py-5 rounded-3xl shadow-xl shadow-yellow-400/20" data-t="save">ÿ≠ŸÅÿ∏</button>
        </div>
    </div>

    <!-- Game Over -->
    <div id="gameOverScreen" class="ui-screen hidden-screen">
        <div class="glass-card p-10 w-80 text-center border-t-[12px] border-yellow-400">
            <h2 class="text-5xl font-black text-white mb-2 uppercase tracking-tighter" data-t="crashed">ÿ™ÿ≠ÿ∑ŸÖ!</h2>
            <p class="text-white/40 text-[10px] font-bold mb-12 tracking-[0.3em] uppercase">Ÿáÿ®Ÿàÿ∑ ÿßÿ∂ÿ∑ÿ±ÿßÿ±Ÿä</p>
            
            <div class="grid grid-cols-2 gap-4 mb-12">
                <div class="bg-white/5 p-5 rounded-[2rem] border border-white/10">
                    <div class="text-[9px] text-white/40 font-bold uppercase mb-2" data-t="score">ÿßŸÑŸÖÿ≥ÿßŸÅÿ©</div>
                    <div class="text-4xl font-black text-white" id="goScore">0</div>
                </div>
                <div class="bg-white/5 p-5 rounded-[2rem] border border-white/10">
                    <div class="text-[9px] text-white/40 font-bold uppercase mb-2" data-t="best">ÿßŸÑÿ±ŸÇŸÖ</div>
                    <div class="text-4xl font-black text-yellow-400" id="goBest">0</div>
                </div>
            </div>
            
            <div class="flex flex-col gap-4">
                <button onclick="Game.start()" class="bg-yellow-400 hover:bg-yellow-300 text-black font-black py-6 rounded-3xl text-xl shadow-2xl shadow-yellow-400/20 active:scale-95 transition-all" data-t="retry">ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿ≠ŸÑŸäŸÇ</button>
                <button onclick="UI.showMenu()" class="bg-white/5 hover:bg-white/10 text-white font-bold py-5 rounded-3xl text-xs tracking-widest uppercase" data-t="home">ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</button>
            </div>
        </div>
    </div>

    <script>
        // ÿ•ÿ∂ÿßŸÅÿ© ÿ¥ÿßÿ¥ÿ© ÿ™ÿ≠ŸÖŸäŸÑ
        window.addEventListener('load', function() {
            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                if(loadingScreen) {
                    loadingScreen.classList.add('hidden');
                }
            }, 1000);
        });

        // Firebase Configuration (ŸäŸÖŸÉŸÜŸÉ ÿ™ÿπÿØŸäŸÑ Ÿáÿ∞Ÿá ÿßŸÑŸÇŸäŸÖ ÿ£Ÿà ÿ•ÿ∂ÿßŸÅÿ™Ÿáÿß ŸÉŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÅŸä HTML)
        const firebaseConfig = {
            apiKey: "YOUR_API_KEY",
            authDomain: "YOUR_AUTH_DOMAIN",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_STORAGE_BUCKET",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID"
        };

        // ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿäÿ©
        let user = null;
        let db = null;
        let auth = null;

        // ŸÖÿ≠ÿßŸàŸÑÿ© ÿ™ŸáŸäÿ¶ÿ© Firebase
        try {
            if (typeof initializeApp !== 'undefined') {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
            }
        } catch(e) {
            console.log('Firebase not initialized, using local storage');
        }

        // ÿØÿßŸÑÿ© ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÖÿµÿßÿØŸÇÿ©
        const initAuth = async () => {
            if (!auth) {
                // ÿ®ÿØŸàŸÜ Firebase - ÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ≠ŸÑŸä ŸÅŸÇÿ∑
                return Promise.resolve();
            }
            
            onAuthStateChanged(auth, (u) => {
                user = u;
                if (user) syncData();
            });

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch(e) {
                console.log('Auth error, using local mode');
            }
        };

        // ÿØÿßŸÑÿ© ŸÖÿ≤ÿßŸÖŸÜÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™
        const syncData = async () => {
            if (!user || !db) {
                // ÿßÿ≥ÿ™ÿ±ÿ¨ÿßÿπ ŸÖŸÜ ÿßŸÑÿ™ÿÆÿ≤ŸäŸÜ ÿßŸÑŸÖÿ≠ŸÑŸä
                Game.best = parseInt(localStorage.getItem('fw_best_score') || '0');
                Game.bird.skin = localStorage.getItem('fw_selected_skin') || 'canary';
                UI.updateBestDisplays();
                return;
            }
            
            try {
                const userDoc = doc(db, 'artifacts', appId, 'users', user.uid, 'profile');
                const snap = await getDoc(userDoc);
                if (snap.exists()) {
                    const data = snap.data();
                    Game.best = data.bestScore || 0;
                    Game.bird.skin = data.selectedSkin || 'canary';
                    UI.updateBestDisplays();
                }
            } catch(e) {
                console.log('Sync error, using local data');
                Game.best = parseInt(localStorage.getItem('fw_best_score') || '0');
                Game.bird.skin = localStorage.getItem('fw_selected_skin') || 'canary';
                UI.updateBestDisplays();
            }
        };

        // ÿØÿßŸÑÿ© ÿ≠ŸÅÿ∏ ÿßŸÑÿ™ŸÇÿØŸÖ
        const saveProgress = async () => {
            // ÿ≠ŸÅÿ∏ ŸÖÿ≠ŸÑŸä ÿØÿßÿ¶ŸÖÿßŸã
            localStorage.setItem('fw_best_score', Game.best);
            localStorage.setItem('fw_selected_skin', Game.bird.skin);
            
            if (!user || !db) return;
            
            try {
                const userDoc = doc(db, 'artifacts', appId, 'users', user.uid, 'profile');
                await setDoc(userDoc, {
                    bestScore: Game.best,
                    selectedSkin: Game.bird.skin,
                    lastUpdated: Date.now()
                }, { merge: true });
            } catch(e) {
                console.log('Save error, data saved locally');
            }
        };

        const hexToRgb = hex => {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : { r: 15, g: 23, b: 42 };
        };
        const lerpColor = (c1, c2, t) => {
            const r1 = hexToRgb(c1), r2 = hexToRgb(c2);
            const r = Math.round(r1.r + (r2.r - r1.r) * t), g = Math.round(r1.g + (r2.g - r1.g) * t), b = Math.round(r1.b + (r2.b - r1.b) * t);
            return `rgb(${r},${g},${b})`;
        };

        const Lang = {
            curr: 'ar',
            dict: {
                ar: {
                    bestScore: "ÿßŸÑÿ£ŸÅÿ∂ŸÑ", playNow: "ÿßŸÜÿ∑ŸÑÿßŸÇ", hangar: "ÿßŸÑÿ£ÿ®ÿ∑ÿßŸÑ", settings: "ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™",
                    language: "ÿßŸÑŸÑÿ∫ÿ©", sfx: "ÿßŸÑÿµŸàÿ™", save: "ÿ≠ŸÅÿ∏", crashed: "ÿ™ÿ≠ÿ∑ŸÖ!", score: "ÿßŸÑŸÖÿ≥ÿßŸÅÿ©", best: "ÿßŸÑÿ±ŸÇŸÖ ÿßŸÑŸÇŸäÿßÿ≥Ÿä", retry: "ÿ•ÿπÿßÿØÿ© ÿßŸÑÿ™ÿ≠ŸÑŸäŸÇ", home: "ÿßŸÑŸÇÿßÿ¶ŸÖÿ©",
                    back: "ÿ±ÿ¨Ÿàÿπ", chooseBird: "ÿßÿÆÿ™ÿ± ÿ®ÿ∑ŸÑŸÉ", unlockAt: "ŸäŸÅÿ™ÿ≠ ÿπŸÜÿØ ", available: "ŸÖÿ™ÿßÿ≠",
                    howToPlay: "ŸÉŸäŸÅŸäÿ© ÿßŸÑŸÑÿπÿ®", t1: "ÿßŸÜŸÇÿ± ŸÑŸÑÿ™ÿ≠ŸÑŸäŸÇ ŸÑŸÑÿ£ÿπŸÑŸâ", t2: "ÿ™ÿ¨ŸÜÿ® ÿßŸÑÿßÿµÿ∑ÿØÿßŸÖ ÿ®ÿßŸÑÿ£ÿπŸÖÿØÿ©", t3: "ÿ™ÿ¨ŸÜÿ® ÿßŸÑÿ≥ŸÇŸàÿ∑ ŸÑŸÑÿ£ÿ≥ŸÅŸÑ", gotIt: "ÿßŸÜÿ∑ŸÑÿßŸÇ!"
                },
                en: {
                    bestScore: "BEST", playNow: "START", hangar: "HEROES", settings: "CONFIG",
                    language: "Language", sfx: "SFX", save: "SAVE", crashed: "CRASHED!", score: "SCORE", best: "RECORD", retry: "REDEPLOY", home: "RETURN",
                    back: "BACK", chooseBird: "SELECT HERO", unlockAt: "Unlock at ", available: "READY",
                    howToPlay: "How to Play", t1: "Click to fly up", t2: "Don't hit the pipes", t3: "Don't fall down", gotIt: "Launch!"
                }
            },
            init() { const saved = localStorage.getItem('fw_lang_v10'); if(saved) this.set(saved); },
            toggle() { this.set(this.curr === 'ar' ? 'en' : 'ar'); AudioSys.play(600, 'sine', 0.1); },
            set(c) {
                this.curr = c; localStorage.setItem('fw_lang_v10', c);
                document.getElementById('htmlTag').dir = c === 'ar' ? 'rtl' : 'ltr';
                document.body.classList.toggle('en', c !== 'ar');
                document.getElementById('langBtn').innerText = c === 'ar' ? 'AR' : 'EN';
                document.querySelectorAll('[data-t]').forEach(el => {
                    const key = el.getAttribute('data-t');
                    if(this.dict[c][key]) el.innerText = this.dict[c][key];
                });
            }
        };

        const AudioSys = {
            ctx: null, settings: { sfx: true },
            init() {
                this.settings = JSON.parse(localStorage.getItem('fw_audio_v10')) || { sfx: true };
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                } catch(e) {
                    console.log('Web Audio API not supported');
                }
                this.updateUI();
            },
            toggleSFX() { 
                this.settings.sfx = !this.settings.sfx; 
                localStorage.setItem('fw_audio_v10', JSON.stringify(this.settings)); 
                this.play(600, 'sine', 0.1); 
                this.updateUI(); 
            },
            updateUI() {
                const sk = document.getElementById('sfxKnob');
                const st = document.getElementById('sfxToggle');
                if(!st) return;
                st.style.backgroundColor = this.settings.sfx ? '#facc15' : 'rgba(255,255,255,0.1)';
                sk.style.left = this.settings.sfx ? '36px' : '4px';
                sk.style.backgroundColor = this.settings.sfx ? '#000' : '#fff';
            },
            play(f, t, d, v=0.08) {
                if(!this.settings.sfx || !this.ctx) return;
                try {
                    if(this.ctx.state === 'suspended') this.ctx.resume();
                    const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                    o.type = t; o.frequency.setValueAtTime(f, this.ctx.currentTime);
                    g.gain.setValueAtTime(v, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + d);
                    o.connect(g); g.connect(this.ctx.destination); o.start(); o.stop(this.ctx.currentTime + d);
                } catch(e) {
                    console.log('Audio play failed');
                }
            }
        };

        // === IMPROVED RENDERER ===
        const Renderer = {
            // Enhanced bird shape with better proportions and details
            drawBird(ctx, skin, frames, vel) {
                ctx.save();
                const wingMove = Math.sin(frames * 0.4) * 0.8;
                const colors = { 
                    canary: ['#fde047', '#f59e0b', '#facc15'], 
                    dove: ['#ffffff', '#e5e7eb', '#d1d5db'], 
                    owl: ['#92400e', '#78350f', '#a16207'],
                    crow: ['#1f2937', '#111827', '#374151'],
                    falcon: ['#64748b', '#475569', '#94a3b8']
                };
                const [bodyColor, accentColor, eyeColor] = colors[skin] || colors.canary;
                
                // Softer glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = bodyColor + "60";
                
                // Main body - more defined oval shape
                const bodyGradient = ctx.createRadialGradient(-5, -5, 5, 0, 0, 25);
                bodyGradient.addColorStop(0, bodyColor);
                bodyGradient.addColorStop(0.7, accentColor);
                bodyGradient.addColorStop(1, bodyColor);
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.ellipse(0, 0, 24, 18, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Head - slightly larger and more prominent
                ctx.beginPath();
                ctx.ellipse(18, -5, 14, 12, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Eye with detailed pupil and highlight
                ctx.fillStyle = "white";
                ctx.beginPath();
                ctx.arc(22, -8, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = skin === 'crow' ? 'white' : 'black';
                ctx.beginPath();
                ctx.arc(23, -8, 3, 0, Math.PI * 2);
                ctx.fill();
                // Eye highlight
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.beginPath();
                ctx.arc(24, -9, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Beak - more detailed shape
                ctx.fillStyle = skin === 'crow' ? '#fbbf24' : '#ea580c';
                ctx.beginPath();
                ctx.moveTo(30, -3);
                ctx.lineTo(38, 0);
                ctx.lineTo(38, 4);
                ctx.lineTo(30, 6);
                ctx.closePath();
                ctx.fill();
                
                // Wing - improved shape with feather details
                ctx.save();
                ctx.rotate(wingMove);
                
                // Wing gradient
                const wingGradient = ctx.createLinearGradient(-15, -10, 5, 15);
                wingGradient.addColorStop(0, accentColor);
                wingGradient.addColorStop(0.5, bodyColor);
                wingGradient.addColorStop(1, bodyColor);
                ctx.fillStyle = wingGradient;
                
                // Wing shape - more bird-like
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.bezierCurveTo(-8, -18, -25, -20, -35, -12);
                ctx.bezierCurveTo(-40, -5, -38, 8, -30, 12);
                ctx.bezierCurveTo(-20, 15, -8, 10, 0, 0);
                ctx.fill();
                
                // Wing feather lines
                ctx.strokeStyle = "rgba(0,0,0,0.2)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-8, 0);
                ctx.lineTo(-25, 3);
                ctx.moveTo(-12, -3);
                ctx.lineTo(-28, -2);
                ctx.moveTo(-18, -8);
                ctx.lineTo(-32, -6);
                ctx.stroke();
                
                ctx.restore();
                ctx.shadowBlur = 0;
                ctx.restore();
            },
            
            // Enhanced pipes with 3D effect and rounded corners
            drawPipe(ctx, x, y, w, h, isTop, theme) {
                // Pipe shadow
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.fillRect(x + 3, isTop ? 0 : y + 3, w, isTop ? y : h);
                
                // Main pipe body
                const pipeGradient = ctx.createLinearGradient(x, 0, x + w * 0.3, 0);
                pipeGradient.addColorStop(0, theme.pipe[2]);
                pipeGradient.addColorStop(0.3, theme.pipe[1]);
                pipeGradient.addColorStop(1, theme.pipe[0]);
                ctx.fillStyle = pipeGradient;
                
                // Rounded pipe body
                ctx.beginPath();
                if(isTop) {
                    ctx.roundRect(x, 0, w, y, 8);
                } else {
                    ctx.roundRect(x, y, w, h, 8);
                }
                ctx.fill();
                
                // Pipe cap with 3D effect
                const capH = 30;
                const capY = isTop ? y - capH : y;
                
                // Cap shadow
                ctx.fillStyle = "rgba(0,0,0,0.4)";
                ctx.fillRect(x - 6 + 2, capY + 2, w + 12, capH);
                
                // Cap main
                const capGradient = ctx.createLinearGradient(x - 6, 0, x + w + 6, 0);
                capGradient.addColorStop(0, theme.pipe[2]);
                capGradient.addColorStop(0.5, theme.pipe[1]);
                capGradient.addColorStop(1, theme.pipe[2]);
                ctx.fillStyle = capGradient;
                ctx.beginPath();
                ctx.roundRect(x - 6, capY, w + 12, capH, 5);
                ctx.fill();
                
                // Cap highlight
                ctx.fillStyle = "rgba(255,255,255,0.3)";
                ctx.fillRect(x - 6 + 3, capY + 3, w + 12 - 6, 3);
                
                // Glossy stripe
                ctx.fillStyle = "rgba(255,255,255,0.2)";
                ctx.fillRect(x + w * 0.1, isTop ? 0 : y, w * 0.08, isTop ? y : h);
            },
            
            drawLeaf(ctx, x, y, size, angle, color) {
                ctx.save(); ctx.translate(x, y); ctx.rotate(angle);
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.ellipse(0, 0, size, size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = "rgba(0,0,0,0.1)";
                ctx.lineWidth = 0.5;
                ctx.beginPath(); ctx.moveTo(-size, 0); ctx.lineTo(size, 0); ctx.stroke();
                ctx.restore();
            },
            
            drawTree(ctx, x, y, scale, color) {
                ctx.save(); ctx.translate(x, y); ctx.scale(scale, scale);
                ctx.fillStyle = "#3e2723"; ctx.fillRect(-5, -10, 10, 10);
                ctx.fillStyle = color;
                for(let i=0; i<3; i++) {
                    ctx.beginPath(); ctx.moveTo(0, -50 + i*15); ctx.lineTo(20, -10 + i*15); ctx.lineTo(-20, -10 + i*15); ctx.fill();
                }
                ctx.restore();
            },
            
            drawCityLight(ctx, x, y) {
                ctx.fillStyle = "#fbbf24";
                ctx.globalAlpha = 0.6 + Math.sin(Date.now() * 0.002) * 0.4;
                ctx.fillRect(x, y, 2, 2);
                ctx.globalAlpha = 1.0;
            },
            
            // Improved mountain renderer
            drawMountain(ctx, x, y, scale, color, peakColor, hasSnow) {
                ctx.save(); ctx.translate(x, y); ctx.scale(scale, scale);
                // Mountain shadow
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(120, -180); ctx.lineTo(240, 0); ctx.fill();
                // Mountain body
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(120, -180); ctx.lineTo(240, 0); ctx.fill();
                // Snow cap
                if (hasSnow) {
                    const snowGradient = ctx.createLinearGradient(0, -180, 0, -120);
                    snowGradient.addColorStop(0, "#ffffff");
                    snowGradient.addColorStop(1, peakColor);
                    ctx.fillStyle = snowGradient;
                    ctx.beginPath(); ctx.moveTo(60, -140); ctx.lineTo(120, -180); ctx.lineTo(180, -140); ctx.fill();
                }
                ctx.restore();
            },
            
            // Dragon body renderer
            drawDragonBody(ctx, x, y, segmentCount) {
                for (let i = 0; i < segmentCount; i++) {
                    const offsetX = x + i * 35;
                    const wave = Math.sin((Date.now() * 0.005) + (i * 0.5)) * 12;
                    ctx.fillStyle = "#dc2626";
                    ctx.beginPath();
                    ctx.ellipse(offsetX, y + wave, 18 - i * 2, 12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Scale pattern
                    ctx.strokeStyle = "#991b1b";
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(offsetX, y + wave, 15 - i * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        };

        // Enhanced themes with parallax movement
        const Themes = [
            { 
                nameAr: "ŸàÿßÿØŸä ÿßŸÑÿ±ÿ®Ÿäÿπ", nameEn: "Spring Valley", flag: "‚òÄÔ∏è", leafColor: "#4ade80",
                bg: ["#0ea5e9", "#bae6fd"], floor: "#15803d", pipe: ["#166534", "#4ade80", "#052e16"],
                parallaxSpeed: 1.0,
                draw(ctx, w, h, f) { 
                    // Parallax trees at different depths
                    for(let i=0; i<5; i++) { 
                        let tx = (i*400 - (f*0.4)%w + w)%w; 
                        Renderer.drawTree(ctx, tx, h-10, 1.2, "#065f46"); 
                    }
                    for(let i=0; i<6; i++) { 
                        let tx = (i*320 - (f*0.7)%w + w)%w; 
                        Renderer.drawTree(ctx, tx, h-10, 0.8, "#059669"); 
                    }
                    // Moving sun with glow
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = "rgba(253, 224, 71, 0.5)";
                    ctx.fillStyle = "#fde047"; 
                    ctx.beginPath(); 
                    ctx.arc(w*0.8 + Math.sin(f*0.01)*50, 100 + Math.cos(f*0.01)*20, 45, 0, Math.PI*2); 
                    ctx.fill(); 
                    ctx.shadowBlur = 0;
                }
            },
            { 
                nameAr: "ÿ®ÿßÿ±Ÿäÿ≥ ŸÅÿ±ŸÜÿ≥ÿß", nameEn: "Paris France", flag: "üá´üá∑", leafColor: "#ddd6fe",
                bg: ["#1e1b4b", "#4338ca"], floor: "#1e1b4b", pipe: ["#334155", "#94a3b8", "#0f172a"],
                parallaxSpeed: 0.9,
                draw(ctx, w, h, f) {
                    let tx = (w*0.7 - (f*0.3)%w + w)%w;
                    // Eiffel Tower parallax
                    ctx.fillStyle = "rgba(0,0,0,0.5)"; 
                    ctx.beginPath(); 
                    ctx.moveTo(tx, h); 
                    ctx.lineTo(tx+40, h-300); 
                    ctx.lineTo(tx+80, h); 
                    ctx.fill();
                    // Twinkling lights
                    for(let i=0; i<6; i++) { 
                        let lightIntensity = Math.sin(f*0.05 + i*2) * 0.5 + 0.5;
                        ctx.fillStyle = `rgba(251, 191, 36, ${lightIntensity})`;
                        ctx.beginPath();
                        ctx.arc(tx + 38, h - 50 - i*40, 2, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            },
            { 
                nameAr: "ÿßŸÑÿ¨Ÿäÿ≤ÿ© ŸÖÿµÿ±", nameEn: "Giza Egypt", flag: "üá™üá¨", leafColor: "#facc15",
                bg: ["#f59e0b", "#fef3c7"], floor: "#d97706", pipe: ["#92400e", "#fbbf24", "#451a03"],
                parallaxSpeed: 0.8,
                draw(ctx, w, h, f) {
                    // Sand dunes with wave effect
                    for(let i=0; i<3; i++) { 
                        let dx = (i*600 - (f*0.2)%w + w)%w; 
                        let wave = Math.sin(f*0.02 + i) * 30;
                        ctx.fillStyle = "rgba(180, 83, 9, 0.3)"; 
                        ctx.beginPath(); 
                        ctx.ellipse(dx + wave, h, 300, 100, 0, Math.PI, Math.PI*2); 
                        ctx.fill(); 
                    }
                    // Pyramids with depth
                    for(let i=0; i<2; i++){ 
                        let px = (w*0.4 + i*450 - (f*0.5)%w + w)%w; 
                        ctx.fillStyle = "rgba(180, 83, 9, 0.5)"; 
                        ctx.beginPath(); 
                        ctx.moveTo(px, h); 
                        ctx.lineTo(px+150, h-200); 
                        ctx.lineTo(px+300, h); 
                        ctx.fill(); 
                    }
                }
            },
            { 
                nameAr: "ÿ∑ŸàŸÉŸäŸà ÿßŸÑŸäÿßÿ®ÿßŸÜ", nameEn: "Tokyo Japan", flag: "üáØüáµ", leafColor: "#f472b6",
                bg: ["#dbeafe", "#f0f9ff"], floor: "#1f2937", pipe: ["#1e293b", "#f472b6", "#0f172a"],
                parallaxSpeed: 1.1,
                draw(ctx, w, h, f) {
                    // Mount Fuji with snow cap
                    for(let i=0; i<2; i++) {
                        let fx = (w*0.2 + i*700 - (f*0.15)%w + w)%w;
                        Renderer.drawMountain(ctx, fx, h, 1.2, "#6b7280", "#e5e7eb", true);
                    }
                    
                    // Pagoda with multiple tiers
                    let tx = (w*0.75 - (f*0.6)%w + w)%w;
                    // Pagoda base
                    ctx.fillStyle = "#374151"; 
                    ctx.fillRect(tx - 30, h - 250, 140, 20);
                    // Pagoda tiers
                    const tiers = 5;
                    for(let i=0; i<tiers; i++) {
                        ctx.fillStyle = "#1f2937";
                        ctx.fillRect(tx - 20 + i*4, h - 230 - i*35, 120 - i*8, 30);
                        // Tier roof
                        ctx.fillStyle = "#374151";
                        ctx.beginPath();
                        ctx.moveTo(tx - 25 + i*4, h - 230 - i*35);
                        ctx.lineTo(tx + 70, h - 260 - i*35);
                        ctx.lineTo(tx + 115 - i*8, h - 230 - i*35);
                        ctx.fill();
                    }
                    
                    // Japanese flags
                    if(f % 200 < 50) {
                        ctx.fillStyle = "#ef4444";
                        ctx.beginPath();
                        ctx.arc(w*0.8, 100 + Math.sin(f*0.02)*20, 20, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            },
            { 
                nameAr: "ÿ®Ÿäÿ¨ŸäŸÜÿ∫ ÿßŸÑÿµŸäŸÜ", nameEn: "Beijing China", flag: "üá®üá≥", leafColor: "#f87171",
                bg: ["#fef2f2", "#fee2e2"], floor: "#881337", pipe: ["#991b1b", "#ef4444", "#450a0a"],
                parallaxSpeed: 0.9,
                draw(ctx, w, h, f) {
                    // Great Wall
                    for(let i=0; i<4; i++) {
                        let wx = (i*450 - (f*0.45)%w + w)%w;
                        ctx.fillStyle = "#78350f";
                        ctx.strokeStyle = "#78350f";
                        ctx.lineWidth = 4;
                        // Wall base
                        ctx.fillRect(wx, h - 150, 100, 30);
                        // Wall towers
                        for(let j=0; j<3; j++) {
                            ctx.fillStyle = "#451a03";
                            ctx.fillRect(wx + j*30, h - 180, 20, 50);
                            // Tower roof
                            ctx.fillStyle = "#991b1b";
                            ctx.beginPath();
                            ctx.moveTo(wx + j*30 - 3, h - 180);
                            ctx.lineTo(wx + j*30 + 10, h - 200);
                            ctx.lineTo(wx + j*30 + 23, h - 180);
                            ctx.fill();
                        }
                    }
                    
                    // Traditional Chinese temple
                    let tx = (w*0.7 - (f*0.4)%w + w)%w;
                    // Main building
                    ctx.fillStyle = "#991b1b";
                    ctx.fillRect(tx, h - 180, 120, 100);
                    // Roof
                    ctx.fillStyle = "#dc2626";
                    ctx.beginPath();
                    ctx.moveTo(tx - 35, h - 180);
                    ctx.bezierCurveTo(tx + 10, h - 240, tx + 50, h - 250, tx + 60, h - 240);
                    ctx.bezierCurveTo(tx + 70, h - 250, tx + 110, h - 240, tx + 155, h - 180);
                    ctx.fill();
                    // Ornaments
                    ctx.fillStyle = "#fbbf24";
                    for(let i=0; i<3; i++) {
                        ctx.beginPath();
                        ctx.arc(tx + 40 + i*20, h - 190, 6, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Dragon motion
                    if(f % 400 < 200) {
                        ctx.fillStyle = "#dc2626";
                        Renderer.drawDragonBody(ctx, w*0.15 + (f%400)*3, h*0.3 + Math.sin(f*0.05)*50, 6);
                    }
                }
            },
            { 
                nameAr: "ŸÑŸÜÿØŸÜ ÿ®ÿ±Ÿäÿ∑ÿßŸÜŸäÿß", nameEn: "London UK", flag: "üá¨üáß", leafColor: "#94a3b8",
                bg: ["#334155", "#64748b"], floor: "#0f172a", pipe: ["#1e293b", "#94a3b8", "#020617"],
                parallaxSpeed: 0.7,
                draw(ctx, w, h, f) {
                    let bx = (w*0.5 - (f*0.4)%w + w)%w;
                    // Big Ben with lights
                    ctx.fillStyle = "#451a03"; 
                    ctx.fillRect(bx, h-350, 70, 350);
                    ctx.fillStyle = "#fbbf24"; 
                    ctx.beginPath(); 
                    ctx.arc(bx+35, h-310, 18, 0, Math.PI*2); 
                    ctx.fill();
                    // Twinkling lights
                    for(let i=0; i<4; i++) { 
                        let intensity = Math.sin(f*0.03 + i) * 0.5 + 0.5;
                        ctx.fillStyle = `rgba(251, 191, 36, ${intensity})`;
                        ctx.beginPath();
                        ctx.arc(bx + 25, h - 50 - i*60, 1.5, 0, Math.PI*2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(bx + 45, h - 50 - i*60, 1.5, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }
        ];

        const Skins = [
            { id: 'canary', nameAr: 'ŸÉŸÜÿßÿ±Ÿä', nameEn: 'Canary', lock: 0, icon: 'üê•' },
            { id: 'dove', nameAr: 'ŸäŸÖÿßŸÖÿ©', nameEn: 'Dove', lock: 20, icon: 'üïäÔ∏è' },
            { id: 'owl', nameAr: 'ÿ®ŸàŸÖÿ©', nameEn: 'Owl', lock: 50, icon: 'ü¶â' },
            { id: 'crow', nameAr: 'ÿ∫ÿ±ÿßÿ®', nameEn: 'Crow', lock: 80, icon: 'üê¶‚Äç‚¨õ' },
            { id: 'falcon', nameAr: 'ÿµŸÇÿ±', nameEn: 'Falcon', lock: 150, icon: 'ü¶Ö' }
        ];

        const Game = {
            canvas: document.getElementById('gameCanvas'), ctx: null,
            state: 'MENU', frames: 0, score: 0, best: 0,
            bird: { y: 0, v: 0, r: 20, skin: 'canary' }, 
            pipes: [], particles: [], leaves: [], themeIdx: 0, 
            speed: 4.5, gap: 195, shake: 0, firstTime: true,

            init() {
                // ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿßŸÑÿπŸÜÿßÿµÿ± ŸÇÿ®ŸÑ ÿßŸÑÿ®ÿØÿ°
                if (!document.getElementById('gameCanvas')) {
                    console.error('Canvas not found!');
                    return;
                }
                
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                Lang.init(); AudioSys.init(); initAuth();
                this.firstTime = localStorage.getItem('fw_onboarded_v10') === null;

                const act = (e) => {
                    if(e.type === 'keydown' && e.code !== 'Space') return;
                    if(this.state === 'PLAYING') { 
                        this.bird.v = -7.4; AudioSys.play(450, 'square', 0.1); 
                        this.spawnParticles(80, this.bird.y, 'white', 4);
                    }
                    if(this.state === 'GAMEOVER' && this.frames > 30) this.start();
                };
                window.addEventListener('keydown', act);
                this.canvas.addEventListener('mousedown', act);
                this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); act(e); }, {passive: false});
                
                // ÿ•ÿÆŸÅÿßÿ° ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ŸàÿßŸÑÿ®ÿØÿ°
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                    this.loop();
                }, 500);
            },
            resize() { this.w = this.canvas.width = window.innerWidth; this.h = this.canvas.height = window.innerHeight; },
            reset() {
                this.bird.y = this.h / 2; this.bird.v = 0;
                this.pipes = []; this.particles = []; this.leaves = []; this.score = 0; this.frames = 0;
                this.themeIdx = 0; this.speed = 4.5; this.gap = 195; this.shake = 0;
                document.getElementById('scoreDisplay').innerText = 0;
                this.updateThemeUI();
                for(let i=0; i<15; i++) this.spawnLeaf(true);
            },
            spawnLeaf(randomX = false) {
                this.leaves.push({
                    x: randomX ? Math.random() * this.w : this.w + 50,
                    y: Math.random() * this.h, size: Math.random() * 5 + 5,
                    vx: -(Math.random() * 2 + 1), vy: Math.random() * 0.5 - 0.25,
                    angle: Math.random() * Math.PI * 2, rot: Math.random() * 0.05 - 0.025
                });
            },
            updateThemeUI() {
                const t = Themes[this.themeIdx];
                if (!t) return;
                document.getElementById('hudFlag').innerText = t.flag;
                document.getElementById('hudLocName').innerText = (Lang.curr === 'ar' ? t.nameAr : t.nameEn);
            },
            handleMainAction() {
                if(this.firstTime) { UI.showTutorial(); } 
                else { this.start(); }
            },
            start() { this.reset(); this.state = 'PLAYING'; UI.showHUD(); },
            gameOver() {
                if(this.state === 'GAMEOVER') return;
                this.state = 'GAMEOVER'; this.shake = 20; AudioSys.play(120, 'sawtooth', 0.4);
                this.spawnParticles(80, this.bird.y, 'red', 20);
                if(this.score > this.best) { this.best = this.score; saveProgress(); }
                UI.showGameOver(this.score, this.best);
            },
            spawnParticles(x, y, color, count) {
                for(let i=0; i<count; i++) {
                    this.particles.push({ x, y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, life: 1, color, size: Math.random()*5+2 });
                }
            },
            update() {
                this.frames++;
                if(this.shake > 0) this.shake *= 0.9; else this.shake = 0;
                this.speed = 4.5 + (this.score * 0.04);
                this.bird.v += 0.38; this.bird.y += this.bird.v;
                
                this.particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; if(p.life <= 0) this.particles.splice(i, 1); });
                this.leaves.forEach((l, i) => {
                    l.x += l.vx - (this.speed * 0.2); l.y += l.vy + Math.sin(this.frames * 0.05 + i) * 0.2;
                    l.angle += l.rot; if(l.x < -50) this.leaves.splice(i, 1);
                });
                
                if(this.frames % 60 === 0) this.spawnLeaf();
                if(this.frames % 90 === 0) {
                    const py = Math.random() * (this.h - this.gap - 250) + 120;
                    this.pipes.push({ x: this.w, y: py, gap: this.gap, passed: false });
                }
                
                for(let i=0; i<this.pipes.length; i++) {
                    let p = this.pipes[i]; p.x -= this.speed;
                    const bx = 80, by = this.bird.y, br = 16; 
                    if(bx + br > p.x && bx - br < p.x + 85) { 
                        if(by - br < p.y || by + br > p.y + p.gap) this.gameOver(); 
                    }
                    if(p.x + 85 < bx && !p.passed) {
                        p.passed = true; this.score++; AudioSys.play(880, 'sine', 0.15, 0.05);
                        document.getElementById('scoreDisplay').innerText = this.score;
                        document.getElementById('scoreDisplay').classList.remove('score-pop');
                        void document.getElementById('scoreDisplay').offsetWidth; 
                        document.getElementById('scoreDisplay').classList.add('score-pop');
                        
                        let nextIdx = Math.min(Themes.length - 1, Math.floor(this.score / 10));
                        if(nextIdx !== this.themeIdx) {
                            this.themeIdx = nextIdx; this.updateThemeUI();
                            UI.toast(Themes[this.themeIdx].flag + " " + (Lang.curr === 'ar' ? Themes[this.themeIdx].nameAr : Themes[this.themeIdx].nameEn));
                        }
                    }
                    if(p.x < -120) this.pipes.splice(i--, 1);
                }
                if(this.bird.y + 20 > this.h || this.bird.y - 20 < 0) this.gameOver();
            },
            draw() {
                const t = Themes[this.themeIdx];
                if (!t) return;
                
                this.ctx.save();
                if(this.shake > 0) this.ctx.translate(Math.random()*this.shake - this.shake/2, Math.random()*this.shake - this.shake/2);
                const grd = this.ctx.createLinearGradient(0,0,0,this.h);
                grd.addColorStop(0, t.bg[0]); grd.addColorStop(1, t.bg[1]);
                this.ctx.fillStyle = grd; this.ctx.fillRect(0,0,this.w,this.h);
                t.draw(this.ctx, this.w, this.h, this.frames);
                this.leaves.forEach(l => Renderer.drawLeaf(this.ctx, l.x, l.y, l.size, l.angle, t.leafColor));
                this.pipes.forEach(pp => {
                    Renderer.drawPipe(this.ctx, pp.x, pp.y, 85, this.h, true, t);
                    Renderer.drawPipe(this.ctx, pp.x, pp.y + pp.gap, 85, this.h, false, t);
                });
                this.particles.forEach(p => {
                    this.ctx.fillStyle = p.color; this.ctx.globalAlpha = p.life;
                    this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); this.ctx.fill();
                });
                this.ctx.globalAlpha = 1;
                if(this.state !== 'MENU') {
                    this.ctx.save(); this.ctx.translate(80, this.bird.y);
                    this.ctx.rotate(Math.min(Math.PI/3, Math.max(-Math.PI/4, this.bird.v * 0.08)));
                    Renderer.drawBird(this.ctx, this.bird.skin, this.frames, this.bird.v);
                    this.ctx.restore();
                }
                this.ctx.restore();
            },
            loop() { 
                if(this.state === 'PLAYING') this.update(); 
                this.draw(); 
                requestAnimationFrame(() => this.loop()); 
            }
        };

        const UI = {
            hideAll() { document.querySelectorAll('.ui-screen').forEach(s => s.classList.add('hidden-screen')); document.getElementById('hud').classList.add('hidden'); },
            showMenu() { this.hideAll(); document.getElementById('mainMenu').classList.remove('hidden-screen'); Game.state = 'MENU'; },
            showHUD() { this.hideAll(); document.getElementById('hud').classList.remove('hidden'); this.updateBestDisplays(); },
            showTutorial() { document.getElementById('tutorialOverlay').classList.remove('hidden-screen'); },
            closeTutorial() { 
                document.getElementById('tutorialOverlay').classList.add('hidden-screen'); 
                Game.firstTime = false; 
                localStorage.setItem('fw_onboarded_v10', 'true');
                Game.start();
            },
            updateBestDisplays() { document.getElementById('bestScoreDisplay').innerText = Game.best; document.getElementById('skinPts').innerText = Game.best; },
            showGameOver(s, b) { document.getElementById('goScore').innerText = s; document.getElementById('goBest').innerText = b; document.getElementById('gameOverScreen').classList.remove('hidden-screen'); },
            showSkins() {
                this.hideAll(); const grid = document.getElementById('skinsGrid'); grid.innerHTML = '';
                this.updateBestDisplays();
                Skins.forEach(s => {
                    const locked = Game.best < s.lock; const active = Game.bird.skin === s.id;
                    const item = document.createElement('div');
                    item.className = `p-6 glass-card flex items-center justify-between border-2 transition-all ${active?'border-yellow-400 bg-white/10':'border-transparent'} ${locked?'opacity-40 grayscale':'cursor-pointer hover:bg-white/10'}`;
                    item.innerHTML = `<div class="flex items-center gap-6"><div class="text-5xl">${s.icon}</div><div><div class="text-white font-black text-lg">${Lang.curr==='ar'?s.nameAr:s.nameEn}</div><div class="text-[10px] text-white/40 font-bold uppercase tracking-widest">${locked?Lang.dict[Lang.curr].unlockAt+s.lock:Lang.dict[Lang.curr].available}</div></div></div><div class="text-2xl">${locked?'üîí':(active?'‚úÖ':'')}</div>`;
                    if(!locked) item.onclick = () => { Game.bird.skin = s.id; AudioSys.play(600, 'sine', 0.05); saveProgress(); UI.showSkins(); };
                    grid.appendChild(item);
                });
                document.getElementById('skinsScreen').classList.remove('hidden-screen');
            },
            showSettings() { this.hideAll(); document.getElementById('settingsScreen').classList.remove('hidden-screen'); AudioSys.updateUI(); },
            toast(msg) {
                const t = document.getElementById('toast'); document.getElementById('toastMsg').innerText = (Lang.curr === 'ar' ? "ŸàÿµŸÑÿ™ ÿ•ŸÑŸâ " : "Arrived at ") + msg;
                t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 3500);
            }
        };

        // ÿ™ÿ£ÿÆŸäÿ± ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®ÿ© ŸÑÿ∂ŸÖÿßŸÜ ÿ™ÿ≠ŸÖŸäŸÑ ŸÉŸÑ ÿßŸÑÿπŸÜÿßÿµÿ±
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                Game.init();
            }, 100);
        });

        window.UI = UI; window.Game = Game; window.Lang = Lang; window.AudioSys = AudioSys;
    </script>

    <!-- Ÿàÿ≠ÿØÿßÿ™ Firebase -->
    <script type="module">
        // ŸäŸÖŸÉŸÜŸÉ ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿπŸÑŸàŸÖÿßÿ™ Firebase ÿßŸÑÿÆÿßÿµÿ© ÿ®ŸÉ ŸáŸÜÿß
        // ÿ£Ÿà ÿ™ÿ™ÿ±ŸÉŸáÿß ŸÅÿßÿ±ÿ∫ÿ© ŸÑŸÑÿπŸÖŸÑ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑŸÖÿ≠ŸÑŸä
        window.__firebase_config = JSON.stringify({
            apiKey: "YOUR_API_KEY",
            authDomain: "YOUR_AUTH_DOMAIN",
            projectId: "YOUR_PROJECT_ID",
            storageBucket: "YOUR_STORAGE_BUCKET",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
            appId: "YOUR_APP_ID"
        });
        window.__app_id = 'flapworld-local';
        
        // ÿßÿ≥ÿ™Ÿäÿ±ÿßÿØ Ÿàÿ≠ÿØÿ© Firebase
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, doc, setDoc, getDoc } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';
        
        // ÿ™ÿπÿ±ŸäŸÅ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÅŸä ÿßŸÑŸÜÿ∑ÿßŸÇ ÿßŸÑÿπÿßŸÖ
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.onAuthStateChanged = onAuthStateChanged;
        window.signInWithCustomToken = signInWithCustomToken;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.setDoc = setDoc;
        window.getDoc = getDoc;
    </script>
</body>
</html>
